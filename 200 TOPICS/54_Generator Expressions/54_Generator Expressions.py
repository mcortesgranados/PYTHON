# Generator expressions in Python provide a concise way to create iterators (generators) from iterable objects (such as lists, tuples, or ranges) 
# using a compact syntax. They are similar to list comprehensions but produce values lazily, one at a time, as they are requested, 
# rather than generating the entire sequence at once. Generator expressions are memory-efficient and suitable for handling large datasets or infinite sequences.

# Here's the general syntax of a generator expression:

# generator_expr = (expression for item in iterable if condition)


# expression: The expression that determines the value of each element generated by the generator.
# item: The variable representing each item in the iterable.
# iterable: The iterable (e.g., list, tuple, range) from which elements are drawn.
# condition (optional): An optional condition that filters the items based on some criteria. Only items for which the condition evaluates to True are included in the generator.
# Example 1: Creating a generator of squares using a generator expression:

numbers = [1, 2, 3, 4, 5]
squared_gen = (x**2 for x in numbers)
print(squared_gen)  # Output: <generator object <genexpr> at 0x7fbfb6b1bba0>


# Example 2: Filtering even numbers using a generator expression:

numbers = [1, 2, 3, 4, 5]
even_gen = (x for x in numbers if x % 2 == 0)
print(even_gen)  # Output: <generator object <genexpr> at 0x7fbfb6b1bcf0>


# Example 3: Creating a generator from a list of tuples using a generator expression:



pairs = [('a', 1), ('b', 2), ('c', 3)]
gen_from_tuples = (key for key, value in pairs)
print(gen_from_tuples)  # Output: <generator object <genexpr> at 0x7fbfb6b1be40>


# You can iterate over generator expressions using a for loop or consume values from them using functions like next() or by converting 
# them to lists using the list() constructor. Since generator expressions produce values lazily, they are memory-efficient and suitable for 
# handling large datasets or infinite sequences.



